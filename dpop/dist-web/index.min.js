function e(e){return btoa(String.fromCharCode.apply(0,e)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}const t=e=>({modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),...e}),n=e=>t({name:"RSA-PSS",hash:{name:"SHA-"+e},saltLength:e/8}),r=e=>t({name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-"+e}}),a=(e,t)=>({name:"ECDSA",namedCurve:t,hash:{name:"SHA-"+e}}),o={PS256:n(256),PS384:n(384),PS512:n(512),RS256:r(256),RS384:r(384),RS512:r(512),ES256:a(256,"P-256"),ES384:a(384,"P-384"),ES512:a(512,"P-521")};var c=e=>{if(!(e in o))throw new TypeError("unrecognized or unsupported JWS algorithm");return o[e]};const i=e=>{return t=(t=btoa(unescape(encodeURIComponent(e)))).replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,""),new Uint8Array(Array.prototype.map.call(atob(t),e=>e.charCodeAt(0)));var t};var p=()=>{let e=21;for(var t="",n=crypto.getRandomValues(new Uint8Array(e));0<e--;)t+="_-0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ"[63&n[e]];return t};async function y(e){const t=c(e);return crypto.subtle.generateKey(t,!1,["sign"])}export default async(t,n,r,a,o,y)=>{const s=await async function(e){const{kty:t,x:n,y:r,e:a,n:o,crv:c}=await crypto.subtle.exportKey("jwk",e);return{kty:t,x:n,y:r,e:a,n:o,crv:c}}(t.publicKey);return async function(t,n,r){const a=JSON.stringify(r),o=JSON.stringify(n),p=[e(i(o)),e(i(a))].join("."),y=i(p),s=await crypto.subtle.sign(c(n.alg),t,y);return`${p}.${e(new Uint8Array(s))}`}(t.privateKey,{typ:"dpop+jwt",alg:n,jwk:s},{...y,iat:Date.now()/1e3|0,jti:p(),htu:r,htm:a,ath:o?e(new Uint8Array(await crypto.subtle.digest({name:"SHA-256"},(new TextEncoder).encode(o)))):void 0})};export{y as generateKeyPair};
//# sourceMappingURL=index.min.js.map